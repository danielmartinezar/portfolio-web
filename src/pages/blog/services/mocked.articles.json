[
  {
    "id": 1,
    "created_at": "2025-07-10",
    "title": "The future of cloud computing: Predictions and trends",
    "resume": "Cloud computing is the on-demand delivery of computing resources like storage, processing, and software over the internet. Discover what the future holds for this transformative technology.",
    "cover_image": "https://images.unsplash.com/photo-1544197150-b99a580bb7a8?w=600&h=400&fit=crop",
    "content": "## Introduction\n\nCloud computing has revolutionized how businesses operate, offering scalable and flexible solutions. In this article, we explore the key predictions and trends shaping the future of cloud technology.\n\n## Key Trends\n\n- **Edge Computing:** Processing data closer to the source for reduced latency.\n- **Serverless Architecture:** Focus on code without managing infrastructure.\n- **Multi-cloud Strategies:** Leveraging multiple providers for resilience.\n\n## Conclusion\n\nThe cloud landscape continues to evolve rapidly, and staying informed about these trends is crucial for developers and businesses alike.",
    "category": "architecture"
  },
  {
    "id": 2,
    "created_at": "2025-06-25",
    "title": "Understanding TypeScript generics in depth",
    "resume": "TypeScript generics allow you to create reusable components that work with a variety of types. Learn how to leverage them effectively in your projects.",
    "cover_image": "https://images.unsplash.com/photo-1555066931-4365d14bab8c?w=600&h=400&fit=crop",
    "content": "## What are Generics?\n\nGenerics provide a way to create components that can work over a variety of types rather than a single one.\n\n## Basic Example\n\n```typescript\nfunction identity<T>(arg: T): T {\n  return arg;\n}\n```\n\n## Constraints\n\nYou can use constraints to limit the types that a generic can accept using the `extends` keyword.",
    "category": "frontend"
  },
  {
    "id": 3,
    "created_at": "2025-06-10",
    "title": "Building scalable APIs with Node.js and Express",
    "resume": "Learn the best practices for building production-ready APIs using Node.js and Express, including error handling, validation, and architecture patterns.",
    "cover_image": "https://images.unsplash.com/photo-1627398242454-45a1465c2479?w=600&h=400&fit=crop",
    "content": "## Project Structure\n\nA well-organized project structure is key to maintainability. Separate your routes, controllers, services, and models into distinct layers.\n\n## Error Handling\n\nCentralize error handling with middleware to keep your controllers clean and consistent.\n\n## Validation\n\nUse libraries like Zod or Joi to validate incoming request data at the boundaries of your application.",
    "category": "backend"
  },
  {
    "id": 4,
    "created_at": "2025-05-20",
    "title": "React performance optimization techniques",
    "resume": "Discover practical techniques to optimize your React applications, from memoization to code splitting and virtualization.",
    "cover_image": "https://images.unsplash.com/photo-1633356122544-f134324a6cee?w=600&h=400&fit=crop",
    "content": "## Memoization\n\nUse `React.memo`, `useMemo`, and `useCallback` to prevent unnecessary re-renders.\n\n## Code Splitting\n\nLazy load components with `React.lazy` and `Suspense` to reduce initial bundle size.\n\n## Virtualization\n\nFor long lists, use libraries like react-window to only render visible items.",
    "category": "frontend"
  },
  {
    "id": 5,
    "created_at": "2025-05-05",
    "title": "Introduction to Docker for frontend developers",
    "resume": "Docker isn't just for backend developers. Learn how containerization can improve your frontend development workflow and deployment process.",
    "cover_image": "https://images.unsplash.com/photo-1605745341112-85968b19335b?w=600&h=400&fit=crop",
    "content": "## Why Docker?\n\nDocker ensures consistency across development, testing, and production environments. No more \"it works on my machine\" issues.\n\n## Basic Dockerfile\n\n```dockerfile\nFROM node:20-alpine\nWORKDIR /app\nCOPY package*.json ./\nRUN npm install\nCOPY . .\nRUN npm run build\n```\n\n## Docker Compose\n\nUse Docker Compose to orchestrate multiple services like your frontend, API, and database together.",
    "category": "devops"
  },
  {
    "id": 6,
    "created_at": "2025-04-15",
    "title": "CSS Grid vs Flexbox: When to use each",
    "resume": "Both CSS Grid and Flexbox are powerful layout tools. Understanding when to use each one will help you write cleaner and more maintainable CSS.",
    "cover_image": "https://images.unsplash.com/photo-1507721999472-8ed4421c4af2?w=600&h=400&fit=crop",
    "content": "## Flexbox\n\nBest for one-dimensional layouts — either a row or a column. Ideal for navigation bars, card rows, and centering content.\n\n## CSS Grid\n\nBest for two-dimensional layouts — rows and columns simultaneously. Perfect for page layouts, galleries, and complex component arrangements.\n\n## Using Both Together\n\nThe best approach often combines both: Grid for the overall page layout and Flexbox for component-level alignment.",
    "category": "frontend"
  },
  {
    "id": 7,
    "created_at": "2025-04-01",
    "title": "Getting started with PostgreSQL and Supabase",
    "resume": "Supabase provides a powerful open-source alternative to Firebase, built on top of PostgreSQL. Learn how to set up your first project and leverage its real-time capabilities.",
    "cover_image": "https://images.unsplash.com/photo-1544383835-bda2bc66a55d?w=600&h=400&fit=crop",
    "content": "## What is Supabase?\n\nSupabase is an open-source Firebase alternative that provides a PostgreSQL database, authentication, instant APIs, and real-time subscriptions.\n\n## Setting Up\n\nCreate a new project on supabase.com, then install the client library with `npm install @supabase/supabase-js`.\n\n## Querying Data\n\n```javascript\nconst { data, error } = await supabase\n  .from('posts')\n  .select('*')\n  .order('created_at', { ascending: false });\n```",
    "category": "backend"
  },
  {
    "id": 8,
    "created_at": "2025-03-18",
    "title": "Mastering Git branching strategies",
    "resume": "A solid Git branching strategy is essential for team collaboration. Explore Git Flow, GitHub Flow, and trunk-based development to find the right fit for your team.",
    "cover_image": "https://images.unsplash.com/photo-1556075798-4825dfaaf498?w=600&h=400&fit=crop",
    "content": "## Git Flow\n\nGit Flow uses long-lived branches like `develop` and `main`, with feature, release, and hotfix branches. Best for projects with scheduled releases.\n\n## GitHub Flow\n\nA simpler model with a single `main` branch and short-lived feature branches. Ideal for continuous deployment.\n\n## Trunk-Based Development\n\nDevelopers commit directly to main (or very short-lived branches). Requires strong CI/CD and feature flags.",
    "category": "devops"
  },
  {
    "id": 9,
    "created_at": "2025-03-05",
    "title": "Web accessibility: A practical guide for developers",
    "resume": "Building accessible websites is not just a legal requirement — it's the right thing to do. Learn practical techniques to make your web apps usable by everyone.",
    "cover_image": "https://images.unsplash.com/photo-1516321318423-f06f85e504b3?w=600&h=400&fit=crop",
    "content": "## Semantic HTML\n\nUsing the correct HTML elements (`nav`, `main`, `article`, `button`) provides built-in accessibility without extra effort.\n\n## ARIA Attributes\n\nWhen semantic HTML isn't enough, ARIA attributes like `aria-label`, `aria-expanded`, and `role` help screen readers understand your UI.\n\n## Keyboard Navigation\n\nEnsure all interactive elements are reachable and operable via keyboard. Test with Tab, Enter, and Escape keys.",
    "category": "frontend"
  },
  {
    "id": 10,
    "created_at": "2025-02-20",
    "title": "Introduction to testing with Vitest and React Testing Library",
    "resume": "Writing tests gives you confidence that your code works as expected. Learn how to set up Vitest with React Testing Library for fast and reliable component testing.",
    "cover_image": "https://images.unsplash.com/photo-1518932945647-7a1c969f8be2?w=600&h=400&fit=crop",
    "content": "## Why Vitest?\n\nVitest is a blazing-fast test runner built on Vite. It supports ESM, TypeScript, and JSX out of the box with minimal configuration.\n\n## Testing Components\n\n```javascript\nimport { render, screen } from '@testing-library/react';\nimport Button from './Button';\n\ntest('renders button text', () => {\n  render(<Button>Click me</Button>);\n  expect(screen.getByText('Click me')).toBeInTheDocument();\n});\n```\n\n## Best Practices\n\nTest behavior, not implementation. Query by accessible roles and labels rather than class names or test IDs.",
    "category": "testing"
  },
  {
    "id": 11,
    "created_at": "2025-02-05",
    "title": "Understanding REST vs GraphQL: Choosing the right API paradigm",
    "resume": "REST and GraphQL are two popular approaches to building APIs. Each has trade-offs in flexibility, performance, and developer experience.",
    "cover_image": "https://images.unsplash.com/photo-1558494949-ef010cbdcc31?w=600&h=400&fit=crop",
    "content": "## REST\n\nREST uses fixed endpoints that return predefined data structures. It's simple, cacheable, and well-understood, but can lead to over-fetching or under-fetching.\n\n## GraphQL\n\nGraphQL provides a single endpoint where clients specify exactly what data they need. It eliminates over-fetching but adds complexity with schemas and resolvers.\n\n## When to Use Each\n\nUse REST for simple CRUD apps with predictable data needs. Use GraphQL when clients have diverse data requirements or when you need to aggregate multiple data sources.",
    "category": "architecture"
  },
  {
    "id": 12,
    "created_at": "2025-01-15",
    "title": "Deploying applications with GitHub Actions and CI/CD",
    "resume": "Automate your build, test, and deployment pipeline with GitHub Actions. Learn how to set up continuous integration and delivery for your projects.",
    "cover_image": "https://images.unsplash.com/photo-1618401471353-b98afee0b2eb?w=600&h=400&fit=crop",
    "content": "## What is CI/CD?\n\nContinuous Integration (CI) automatically builds and tests your code on every push. Continuous Delivery (CD) automates deployment to staging or production.\n\n## Basic Workflow\n\n```yaml\nname: CI\non: [push, pull_request]\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n      - run: npm ci\n      - run: npm test\n      - run: npm run build\n```\n\n## Deployment\n\nAdd a deploy step that runs only on the main branch to push your built application to your hosting provider.",
    "category": "devops"
  }
]
